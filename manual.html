<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Manual</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div id="container">
    <div id="header">
      <h1>Manual</h1>
    </div>

    <div id="nav">
  | <a href="https://irdvo.github.io//ffl">ffl</a> | <a href="http://irdvo.github.io/gpxlib">gpxlib</a> - <a href="manual.html">manual</a> - <a href="doxy/index.html">docs</a> - <a href="http://github.com/irdvo/gpxlib">github</a> | <a href="http://irdvo.github.io/htmloo">htmloo</a> | <a href="https://irdvo.github.io/ofc">ofc</a> |
    </div>

    <div id="article">
<h2>Manual</h2>

<p>The library supports browsing an existing gpx file and creating a new gpx file
by using reflection. Changing a gpx file and validating a gpx file are still
under development.</p>

<h3>Browsing and iterating</h3>

<p>For browsing a gpx file you need to parse the file:</p>

<pre>
#include "gpx/Parser.h"
    
void main(int argc, char *argv[])
{
  ifstream stream("file.gpx");

  if (stream.is_open())
  {
    gpx::Parser parser(&amp;cerr);

    gpx::GPX *root = parser.parse(stream);

    if (root == 0)
    {
      cerr &lt;&lt; "Parsing of file.gpx failed due to " &lt;&lt; parser.errorText() &lt;&lt; " on line " &lt;&lt; parser.errorLineNumber() &lt;&lt; " and column " &lt;&lt; parser.errorColumnNumber() &lt;&lt; endl;
    }
    else
    {
      cout &lt;&lt; "Version: " &lt;&lt; root-&gt;version().getValue() &lt;&lt; endl; 
    }
    stream.close();
  }
}
</pre>

<p>First you create a gpx::Parser object with a output stream for any errors. gpx
is the namespace of the library. With this parser you parse the file with 
parser.parse(stream). The parser returns the root node of the gpx document which is
of the type gpx::GPX. If the root node is zero, the file.gpx was not correct xml. With
parser.errorText(), parser.errorLineNumber() and parser.errorColumnNumber() you can get 
more information about the problem with the gpx file.</p>

<p>If the root pointer was valid, the root pointer points to the attributes and elements
of this node. For example root-&gt;version() addresses the version attribute of the 
root node. This field is always present, so to check if the attribute was actual present
in the gpx file, you can test that by root-&gt;version().used(). The value of the 
attribute can be read by root-&gt;version().getValue().</p>

<p>Repeating elements in the node can be addressed by root-&gt;wpts().list(). This 
returns a reference to a STL-list with gpx::WPT objects. For example:</p>

<pre>list&lt;gpx::WPT*&gt; &amp;wpts = root-&gt;wpts().list();</pre>

<p>It is also possible to iterate all the attributes and elements that were present
in the gpx file. This can be done by:</p>

<pre>
for (list&lt;gpx::Node*&gt;::iterator node = root-&gt;getAttributes().begin(); node != root-&gt;getAttributes().end; ++node)
{
  cout &lt;&lt; (*node)-&gt;getName() &lt;&lt; ":" &lt;&lt; (*node)-&gt;getValue() &lt;&lt; endl;
}

for (list&lt;gpx::Node*&gt;::iterator node = root-&gt;getElements().begin(); node != root-&gt;getElements().end; ++node)
{
  cout &lt;&lt; (*node)-&gt;getName() &lt;&lt; ":" &lt;&lt; (*node)-&gt;getValue() &lt;&lt; endl;
}
</pre>

<h3>Creating and reflection</h3>

<p>To create a gpx document using the library, you start with a GPX object:</p>

<pre>gpx::GPX *root = new GPX();</pre>

<p>Then you add attributes and elements to this node:</p>

<pre>
gpx::Node *attribute = root-&gt;version().add();
gpx::WPT  *wpt       = root-&gt;wpts().add(&amp;cerr);
gpx::Node *extension = root-&gt;add("xmlns",gpx::Node::ATTRIBUTE);
</pre>

<p>This adds two attributes and one element to the root node. The first is the 
version attribute, the second is the waypoint element and third is the extension
xmlns, which is standard not a member of the GPX object. In all variants you can add
an optional pointer to an output stream for reporting warnings and errors during
adding of the nodes.</p>

<p>The next step is giving the new attributes and elements values:</p>

<pre>
attribute-&gt;setValue("1.1");
wpt-&gt;lat().add()-&gt;setValue("1.60000");
extension-&gt;setValue("http://www.topografix.com/GPX/1/1");
</pre>

<p>In the first line the version attribute is assigned the value 1.1. In the 
second line the lat attribute is added to the wpt element and is directly
assigned by a value. In the third line the extension attribute is set by
a link.</p>

<p>During creating of a gpx document you can use reflection to determine which 
attributes and elements a node supports:</p>

<pre>
for (list&lt;gpx::Node*&gt;::iterator node = root-&gt;getInterfaces().begin(); node != root-&gt;getInterfaces().end; ++node)
{
  cout &lt;&lt; (*node)-&gt;getName() &lt;&lt; ":" &lt;&lt; ((*node)-&gt;getType() == gpx::Node::ATTRIBUTE ? "Attribute" : "Element") &lt;&lt; endl;
}
</pre>

<p>This gives an overview of all the attributes and elements the root node supports.</p>

<p>The gpx document can be written to file using the gpx::Writer:</p>

<pre>
ofstream stream("output.gpx");

if (stream.is_open())
{
  gpx::Writer writer;

  writer.write(stream, root, true);

  stream.close()
}
</pre>

<p>The writer object writes the root node (and its children) to the stream. The
true flags indicaties that the info should be pretty printed. A false flag results
in a long xml line.</p>

<h3>Validation</h3>

<p>The validation support in the library is still under development.</p>

<h3>Changing</h3>

<p>The adding and changing of attributes and elements are supported by the 
library. The deleting of nodes is not yet implemented.</p>

    </div>

    <div id="footer">
    <p>
     Last updated: 2016-01-31</p>
    </div>
  </div>
</body>
</html>
